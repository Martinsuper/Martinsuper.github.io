<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docs on My New Hugo Site</title>
    <link>http://localhost:1313/docs/</link>
    <description>Recent content in Docs on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="http://localhost:1313/docs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>我的第一篇文章</title>
      <link>http://localhost:1313/docs/my-first-post/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/my-first-post/</guid>
      <description>我的第一篇文章 # 我的第一篇博客，欢迎大家关注。 Hugo 是一个静态网站生成器，它使用 Go 语言开发。&#xA;最近部署前端项目的时候感觉很麻烦，每次改好代码都需要手动上传文件到阿里云OSS，今天决定使用 GitHub Actions 自动化打包部署到阿里云 OSS。&#xA;设置 GitHub 机密变量 # 因为阿里云上传需要 access_key_id、access_key_secret 等敏感信息，这种信息不方法放到仓库或者 workflow 里面，放到 GitHub secrets 里面就比较合适了。&#xA;配置如下图&#xA;配置 GitHub Actions 具体配置如下图：&#xA;name: Deploy to Aliyun OSS on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v3 - name: Set up Node.js uses: actions/setup-node@v3 with: node-version: &amp;#39;16&amp;#39; - name: Install dependencies working-directory: ./seed-vite run: | npm install npm run build - name: Install ossutil run: | curl https://gosspublic.</description>
    </item>
    <item>
      <title>我的第一篇文章</title>
      <link>http://localhost:1313/docs/my-second-post/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/my-second-post/</guid>
      <description>我的第一篇文章 # 我的第一篇博客，欢迎大家关注。 Hugo 是一个静态网站生成器，它使用 Go 语言开发。&#xA;最近部署前端项目的时候感觉很麻烦，每次改好代码都需要手动上传文件到阿里云OSS，今天决定使用 GitHub Actions 自动化打包部署到阿里云 OSS。&#xA;设置 GitHub 机密变量 # 因为阿里云上传需要 access_key_id、access_key_secret 等敏感信息，这种信息不方法放到仓库或者 workflow 里面，放到 GitHub secrets 里面就比较合适了。&#xA;配置如下图&#xA;配置 GitHub Actions 具体配置如下图：&#xA;name: Deploy to Aliyun OSS on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v3 - name: Set up Node.js uses: actions/setup-node@v3 with: node-version: &amp;#39;16&amp;#39; - name: Install dependencies working-directory: ./seed-vite run: | npm install npm run build - name: Install ossutil run: | curl https://gosspublic.</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/docs/java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/java/</guid>
      <description>Java面向对象编程（OOP）的概念主要包括以下几个方面：&#xA;类和对象：&#xA;类（Class）：类是对象的蓝图或模板，它定义了对象的属性（也称为字段或成员变量）和方法（也称为成员函数）。例如，一个类可以表示汽车，定义了汽车的属性（颜色、型号）和方法（启动、停止）。 对象（Object）：对象是类的实例，它是具体的数据结构，包含了类中定义的属性和方法的值和行为。每个对象都是独立的，即使它们属于同一类。在Java中，对象可以通过使用new关键字来创建。 封装（Encapsulation）：&#xA;封装是将数据和方法封装在类中的概念。它使得对象的内部状态对外部是隐藏的，只能通过公共方法来访问和修改。这提高了代码的安全性和可维护性。 继承（Inheritance）：&#xA;继承允许一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码的重用。在Java中，可以使用extends关键字来实现继承。 多态性（Polymorphism）：&#xA;多态性允许不同的对象对相同的方法做出不同的响应。这可以通过方法的重写和接口实现来实现。在Java中，多态性提高了代码的灵活性和可扩展性。 抽象（Abstraction）：&#xA;抽象是指将复杂的系统分解为更简单的部分。在OOP中，我们可以通过创建抽象类或接口来定义对象的通用行为。 这五个概念构成了Java面向对象编程的核心，它们共同帮助开发者更有效地组织和管理代码，提高代码的可重用性、可维护性和可扩展性。这些概念在Java编程中得到了广泛的应用，并且为开发者提供了一种更高级别的抽象方式来解决复杂的问题。&#xA;Java中的类和对象在面向对象编程（OOP）中扮演着不同的角色，它们之间的主要区别可以归纳如下：&#xA;定义与用途 类（Class）： 类是一个抽象的、概念上的蓝图或模板，它定义了对象的属性和方法。 类是对现实世界中一组具有共同特征的事物的抽象描述，例如“人类”、“汽车”等。 类中定义了对象的状态（通过字段/属性）和行为（通过方法）。 类使用class关键字进行声明，如class Student {}。 对象（Object）：&#xA;对象是类的具体实例，是真实存在的、可操作的实体。 对象是类的一个具体表现，具有类所定义的属性和方法，并且这些属性和方法有其具体的值和行为。 对象是通过new关键字基于类创建的，例如Student s1 = new Student();。 对象可以是物理实体（如手机、电脑），也可以是逻辑实体（如银行账户、订单）。 2. 特性与关系 特性：&#xA;类是一个逻辑实体，描述了对象的属性和行为，但不占用内存空间。 对象是一个真实世界的实体，是类的实例，具有状态和行为，并占用内存空间。 关系：&#xA;类是对象的模板或蓝图，对象是根据类创建的实例。 一个类可以创建多个对象，而每个对象都是类的唯一实例。 类的属性和方法定义了对象的通用特性，而对象的属性和方法的具体值和行为则取决于对象的状态和上下文。 3. 实例化与引用 实例化：根据类创建对象的过程称为实例化。使用new关键字和类的构造函数来创建对象。&#xA;引用：在Java中，我们通过引用变量来操作对象。引用变量是对象的句柄或指针，它存储了对象在内存中的地址。&#xA;内存占用 类在定义时并不占用内存空间，只有在创建对象时，对象才会占用内存空间。 生命周期 类的生命周期通常与程序的运行时间相同，而对象的生命周期可能随其创建和销毁而变化。 访问与操作 我们可以通过对象来访问和修改其属性和方法，但不能直接访问类的属性和方法（除了类的静态属性和静态方法）。 通过以上的分析，我们可以看出Java中的类和对象在定义、特性、关系、实例化、内存占用、生命周期以及访问和操作等方面都存在着明显的区别。 </description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/docs/java_learn_plan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/java_learn_plan/</guid>
      <description> Java 开发工程师需要掌握的技能&#xA;Java核心技术：&#xA;深入理解Java编程语言的核心特性，包括语法、面向对象编程（OOP）的概念和实践、集合框架、异常处理等。 熟练掌握Java 8及以上版本的新特性，如Lambda表达式、Stream API、Optional类等。 Java框架与库：&#xA;精通Spring框架，包括Spring MVC、Spring Boot、Spring Data等，理解其内部原理并能灵活应用。 熟悉Hibernate、MyBatis等ORM框架，理解其优缺点并能在实际项目中正确选择。 掌握JPA（Java Persistence API）规范，了解其与Hibernate等ORM框架的关系。 并发编程与多线程：&#xA;深入理解Java并发编程模型，包括线程、锁、同步机制等。 熟练使用java.util.concurrent包中的类与接口进行高效并发编程。 掌握常见的并发问题，如死锁、饥饿、竞态条件等，并能提出解决方案。 Java虚拟机（JVM）：&#xA;深入理解JVM的工作原理，包括内存模型、垃圾回收机制、类加载机制等。 能够进行JVM调优，分析和解决内存泄漏、性能瓶颈等问题。 数据库与SQL：&#xA;熟练掌握关系型数据库（如MySQL、Oracle等）的基本操作，包括增删改查、索引、事务等。 理解SQL调优的基本原理，能编写高效的SQL语句。 了解NoSQL数据库（如Redis、MongoDB等）的基本原理和应用场景。 Web开发技术：&#xA;熟悉Java Web开发的基本技术栈，包括Servlet、JSP、JSTL等。 了解RESTful API的设计和实现原理，能编写符合RESTful规范的Web服务。 熟练使用前端技术（如HTML、CSS、JavaScript）与后端进行数据交互和前后端分离开发。 版本控制与团队协作：&#xA;熟练掌握Git等版本控制工具，了解分支、合并、冲突解决等基本操作。 熟悉团队协作流程，如代码审查、持续集成/持续部署（CI/CD）等。 性能调优与测试：&#xA;能够分析和优化Java应用程序的性能瓶颈，熟悉使用JProfiler、VisualVM等工具进* 行性能监控和分析。 掌握单元测试、集成测试的基本概念和方法，熟练使用JUnit等测试框架编写测试用例。 软技能：&#xA;具备良好的沟通能力，能够与技术团队和非技术人员有效沟通。 具备较强的问题解决能力，能独立分析和解决复杂的技术问题。 具备较强的学习能力，能够快速掌握新技术和新方法。 具有良好的团队协作能力，能够积极参与团队讨论和协作开发。 </description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/docs/springboot/resource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/springboot/resource/</guid>
      <description>Resource # Resource 一、基本信息 二、知识储备 三、基本描述 四、主要功能 五、接口源码 六、主要实现 七、最佳实践 八、与其他组件的关系 九、常见问题 一、基本信息 # ✒️ 作者 - Lex 📝 博客 - 掘金 📚 源码地址 - github&#xA;二、知识储备 # I/O知识 了解文件、路径、输入/输出流等基础概念。 类路径（Classpath） 了解什么是类路径，以及如何从类路径中加载资源。 URL和URI概念 这对于理解如何从网络或其他协议中加载资源是必要的。 三、基本描述 # Resource 是 Spring 框架中用于简化和统一对底层资源（如文件、classpath 资源、URL 等）的访问的一个核心接口。它为不同来源的资源提供了一个共同的抽象，并隐藏了具体资源访问的细节。在 Java 开发中，资源的访问是常见的需求，如读取配置文件、图片、音频等。但 Java 的标准库为不同类型的资源提供了不同的访问机制：例如，对于文件系统中的资源，我们可能使用 java.io.File；对于 classpath 中的资源，我们可能使用 ClassLoader 的 getResource 或 getResourceAsStream 方法；对于网络资源，我们可能使用 java.net.URL。这些不同的机制意味着我们需要了解和使用多种方式来访问资源，这导致的问题是代码复杂性增加、重复代码以及可能的错误。为了提供一个统一、简化和更高级的资源访问机制，Spring 框架引入了 Resource 接口，这个接口为所有的资源提供了一个统一的抽象。&#xA;四、主要功能 # 统一的资源抽象 无论资源来自于文件系统、classpath、URL 还是其他来源，Resource 接口都为其提供了一个统一的抽象。 资源描述 通过 getDescription() 方法，每个 Resource 实现都可以为其所代表的底层资源提供描述性信息，这对于错误处理和日志记录特别有用。 读取能力 Resource 提供了 getInputStream() 方法，允许直接读取资源内容，而无需关心资源的实际来源。 存在性与可读性 Resource 提供了 exists() 和 isReadable() 方法来确定资源是否存在及其是否可读。 开放性检查 isOpen() 方法用于检查资源是否表示一个已经打开的流，这有助于避免重复读取流资源。 URI 和 URL 访问 Resource 允许通过 getURI() 和 getURL() 方法获取其底层资源的 URI 和 URL，这为进一步的资源处理提供了可能。 文件访问 当资源代表一个文件系统中的文件时，可以通过 getFile() 直接访问该文件。 多种实现 Spring 提供了多种 Resource 的实现，以支持不同来源的资源，如 ClassPathResource、FileSystemResource 和 UrlResource 等。 五、接口源码 # InputStreamSource 是一个简单的接口，用于提供一个输入流。它被设计为可以多次返回一个新的、未读取的输入流，这对于那些需要多次读取输入流的API。</description>
    </item>
  </channel>
</rss>
